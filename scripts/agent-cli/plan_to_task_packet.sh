#!/usr/bin/env bash
# plan_to_task_packet.sh — Bootstrap implementation Task Packet from final plan
#
# Usage:
#   plan_to_task_packet.sh \
#     --plan-file .tmp/plan-pipeline/final.md \
#     --task-dir .tmp/task/20260218-001 \
#     --goal "Implement approved plan"
#
# Exit codes:
#   0  Success
#   1  Failure
#   2  Bad arguments

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/lib/log.sh"

PLAN_FILE=""
TASK_DIR=""
GOAL=""
ROUTING_INTENT="safe_impl"

usage() {
	cat <<'EOF'
Usage: plan_to_task_packet.sh --plan-file <file> --task-dir <dir> --goal <text> [--intent <intent>]

Options:
  --plan-file <file>  Final plan markdown generated by run_plan_pipeline.sh
  --task-dir <dir>    Destination Task Packet directory (e.g., .tmp/task/20260218-001)
  --goal <text>       Goal sentence for implementation task
  --intent <intent>   routing.intent (default: safe_impl)
EOF
}

while [[ $# -gt 0 ]]; do
	case "$1" in
	--plan-file)
		PLAN_FILE="$2"
		shift 2
		;;
	--task-dir)
		TASK_DIR="$2"
		shift 2
		;;
	--goal)
		GOAL="$2"
		shift 2
		;;
	--intent)
		ROUTING_INTENT="$2"
		shift 2
		;;
	-h | --help)
		usage
		exit 0
		;;
	*)
		log_error "Unknown argument: $1"
		usage
		exit 2
		;;
	esac
done

if [[ -z $PLAN_FILE || -z $TASK_DIR || -z $GOAL ]]; then
	log_error "--plan-file, --task-dir, and --goal are required"
	usage
	exit 2
fi

if [[ ! -s $PLAN_FILE ]]; then
	log_error "Plan file not found or empty: $PLAN_FILE"
	exit 1
fi

TASK_ID="$(basename "$TASK_DIR")"
GOAL_YAML=$(python3 -c 'import json,sys; print(json.dumps(sys.argv[1]))' "$GOAL")
INPUTS_DIR="${TASK_DIR}/inputs"
ATTACH_DIR="${INPUTS_DIR}/attachments"
OUTPUTS_DIR="${TASK_DIR}/outputs"
STATE_DIR="${TASK_DIR}/state"
DONE_DIR="${TASK_DIR}/done"

mkdir -p "$ATTACH_DIR" "$OUTPUTS_DIR" "$STATE_DIR" "$DONE_DIR"

cp "$PLAN_FILE" "${ATTACH_DIR}/implementation_plan.md"

cat >"${INPUTS_DIR}/user_request.md" <<EOF
Implement the approved plan in \`inputs/attachments/implementation_plan.md\`.
Goal: ${GOAL}

Rules:
- Follow the plan unless verification failure requires minimal deviation.
- Keep changes within scope.allow and scope.deny in manifest.yaml.
- Prioritize small, verifiable increments.
EOF

cat >"${INPUTS_DIR}/context_pack.md" <<'EOF'
## 0. Goal
Implement the approved execution plan safely and verifiably.

## 1. Non-goals
- Do not redesign unrelated architecture.
- Do not change out-of-scope files.

## 2. Scope
### Allowed paths
- src/
- tests/
- scripts/

### Denied paths
- .env
- secrets/

## 3. Acceptance Criteria
- [ ] Implementation follows the approved plan unless a verified blocker requires a minimal revision.
- [ ] Verification commands pass.

### Verify Commands
```bash
# Replace with project-specific commands before execution
```

## 4. Fixed Decisions
- Use the approved plan as the primary specification.

## 5. Files to Read
- `inputs/attachments/implementation_plan.md` — approved plan to execute

## 6. Prohibited Actions
- Do not add dependencies without approval.
- Do not disable tests to make checks pass.

## 7. Current State
- Task packet initialized from final plan.

## 8. Open Questions
- None.

## 9. Change History
| Date | Change |
| ---- | ------ |
|      | Initialized from plan_to_task_packet.sh |
EOF

cat >"${TASK_DIR}/manifest.yaml" <<EOF
task_id: "${TASK_ID}"
goal: ${GOAL_YAML}

routing:
  intent: ${ROUTING_INTENT}

scope:
  allow:
    - src/
    - tests/
    - scripts/
  deny:
    - .env
    - secrets/

acceptance:
  commands: []
  criteria:
    - "Implementation follows approved plan and passes verification commands"

budgets:
  retry_budget: 2
  paid_call_budget: 10
  max_wallclock_sec: 900

context:
  digest_policy: auto

security:
  redaction_patterns: []
  forbidden_paths:
    - ".env"
    - "secrets/"
EOF

log_ok "Task Packet initialized: ${TASK_DIR}"
log_info "Next: edit ${TASK_DIR}/manifest.yaml acceptance.commands/scope, then run dispatch pipeline."
exit 0
